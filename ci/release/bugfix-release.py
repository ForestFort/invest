# encoding=UTF-8
"""bugfix-release.py"""

import sys
import shutil
import subprocess
import logging
logging.basicConfig(level=logging.DEBUG)

import github3
import requests

# Check to see if we should do a release.
#    True if master and a tag point to the same commit.
#    False otherwise
#
# 1. Make changes to files
# 2. Commit the files
#    * See
#    https://github.community/t5/GitHub-Actions/how-does-one-commit-from-an-action/m-p/31870#M921
#      for an example of doing this with github3.py.
# 3. Tag the new commit
# 4. Create a release that includes the updated text from the changelog.
#    * Must be done via the github3 api

# GITHUB_TOKEN and GITHUB_REPOSITORY are both set as part of github actions
def _main():
    github = github3.login(token=os.environ['GITHUB_TOKEN'])
    repository = github.repository(*os.environ['GITHUB_REPOSITORY'].split('/'))


def _sh(command, capture_output=False):
    process_data = subprocess.run(command, capture_output=capture_output)
    return process_data.stdout.rstrip().decode('UTF-8')


def get_latest_rev_on_userguide():
    r = requests.get('https://api.github.com/repos/natcap/invest.users-guide/commits/master')
    return r.json()['sha']


def update_userguide_rev_in_makefile(new_rev):
    if not os.path.exists('build'):
        os.makedirs('build')
    new_makefile_path = os.path.join('build', 'Makefile')
    makefile_path = 'Makefile'

    # The Makefile uses \n newlines, so enforce that newline character in the
    # new Makefile.
    with open(new_makefile_path, 'w', newline='\n') as new_makefile:
        with open(makefile_path) as makefile:
            for line in makefile:
                if line.startswith('GIT_UG_REPO_REV'):
                    line_prefix, old_sha = line.split(':=')
                    print('Replacing Makefile SHA %s with %s' % (
                        old_sha.rstrip(), new_rev))
                    new_makefile.write('%s:= %s\n' % (
                        line_prefix, new_rev))
                else:
                    new_makefile.write(line)

    shutil.copyfile(new_makefile_path, makefile_path)


def main():
    current_branch = _sh(['git rev-parse --abbrev-ref HEAD'])
    LOGGER.info("Executing on branch %s", current_branch)

    head_tags = _sh(['git', 'tag', '--points-at', current_branch])
    if head_tags != "":
        LOGGER.info("Tags already exist for HEAD on %s: %s",
                    current_branch, head_tags)
        # Exiting at this point is not an error, it's planned behavior.
        sys.exit(0)

    # Determine the next release number
    next_release_number = None # Get this from get-release-number.py

    # Increment the UG version
    latest_ug_rev = get_latest_rev_on_userguide()
    update_userguide_rev_in_makefile(latest_ug_rev)

    # Commit changes to this repository
    # I'm explicitly only committing changes to the files that we know to have
    # been modified in this script to avoid accidentally committing changes to
    # files during testing.
    commit_message = (
        f"Auto-committing updates for the {next_release_number} release.\n"
        "\n"
        "This commit has been automatically generated by the script at\n"
        "ci/release/bugfix-release.py."
    )
    _sh(f'git commit Makefile HISTORY.rst -m "{commit_message}"',
        capture_output=False)

    # Tag this local repository.
    # Using an annotated commit here because it'll contain extra information
    # about the commit itself.  Seems useful since this will be an automated
    # script.
    tag_commit_message = f"{next_release_number} release."
    _sh(f'git tag -a {next_release_number} -m "{tag_commit_message}"',
       capture_output=False)

    # Push changes to this repository.
    repository = (
        f"https://{os.environ['GITHUB_ACTOR']}:{os.environ['GITUB_TOKEN']}"
        f"@github.com/{os.environ['GITHUB_REPOSITORY']}.git"
    )
    _sh(f'git push {repository} {next_release_number}',
       capture_output=False)





