name: Automated Bugfix Release
on:
    schedule:
        # Noon PST on Tuesday of each week
        #- cron: '0 20 * * 2'
        #
        # For debugging, run this once every 5 minutes
        - cron: '*/5 * * * *'

jobs:
    create-bugfix-release:
        name: Create a bugfix release
        runs-on: ubuntu-latest
        env:
            TARGET_BRANCH: feature/automated-releases
        steps:
            - uses: actions/checkout@v2
              with:
                  ref: ${{ env.TARGET_BRANCH }}
                  fetch-depth: 0  # fetch complete history

            - run: git fetch origin +refs/tags/*:refs/tags/*

            - uses: actions/setup-python@v1
              with:
                  python-version: 3.7

            - run: pip install --upgrade requests toml
            - run: pip install $(python -c "import toml;print(' '.join(toml.load('pyproject.toml')['build-system']['requires']))")
            - run: sudo apt-get update --fix-missing && sudo apt-get install pandoc

            -   env:
                    TARGET_BRANCH: ${{ env.TARGET_BRANCH }}
                    GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
                run: |
                    if hub ci-status $TARGET_BRANCH
                    then
                        echo "There are test failures on $TARGET_BRANCH; aborting release."
                        exit 1
                    fi

                    # Don't do a bugfix release if target branch's HEAD already has a tag
                    # git-describe exits 0 if a tag is found, 128 if not.
                    if git describe --exact-match --tags $TARGET_BRANCH
                    then
                        echo "The latest commit on $TARGET_BRANCH already has a tag"
                    else
                        LATEST_TAG=$(git describe --tags | awk -F '-' '{print $1}')
                        echo "Latest tag on $TARGET_BRANCH is $LATEST_TAG"
                        if [[ $LATEST_TAG =~ '^[0-9]+\.[0-9]+\.[0-9]+$' ]]
                        then
                            echo "$LATEST_TAG identified as a full release."
                            echo "Proceeding with automated bugfix release."
                        else
                            echo "$LATEST_TAG does not conform to bugfix versioning."
                            echo "This script does not know how to handle non-bugfix releases."
                            echo "Aborting"
                            exit 1
                        fi

                        export BUGFIX_VERSION=$(python setup.py --version | awk -F '.' '{print $1"."$2"."$3+1}')

                        # Update the UG hash in the Makefile
                        # This could be done with curl and sed, but it'll be easier
                        # to read this way.
                        python ci/release/increment-userguide-revision.py

                        # Update HISTORY with the tag and today's date.
                        python ci/release/update-history.py $BUGFIX_VERSION $(date "+%Y-%m-%d")

                        # Need to set up these committer details before
                        # anything can be committed.
                        git config user.email "jdouglass@stanford.edu"
                        git config user.name "James Douglass"

                        # Commit changes and make an annotated tag.
                        # Commit SHA saved to $NEW_COMMIT_SHA for future
                        # reference
                        git commit Makefile HISTORY.rst \
                            -m "Auto-committing updates for the $BUGFIX_VERSION release"
                        export NEW_COMMIT_SHA=$(git log -n1 --format=format:"%H")
                        git tag -a $BUGFIX_VERSION -m "$BUGFIX_VERSION release."

                        # Only push revisions needed to push the tag created.
                        # NOTE: If changes were pushed to $TARGET_BRANCH before
                        # we try to push this release, the push will fail and
                        # we'll avoid the race condition.
                        GIT_REPO=https://$GITHUB_ACTOR:$GITHUB_TOKEN@github.com/$GITHUB_REPOSITORY.git
                        git push --tags $GIT_REPO $TARGET_BRANCH

                        RELEASE_MESSAGE_FILE=release_message.md
                        VERSION=$BUGFIX_VERSION ./ci/release/build-release-text-from-history.sh > $RELEASE_MESSAGE_FILE
                        cat $RELEASE_MESSAGE_FILE  # for debugging, just in case.

                        # Create a release object based on the text from HISTORY.
                        # This requires that the tag already exists in the
                        # repository on github.
                        # NOTE: creating a GitHub release creates the tag.
                        #       The InVEST binaries are created in response to
                        #       this release object being created.  See the
                        #       upload-binaries-to-release build job in
                        #       .github/workflows/binary-applications.yml.
                        hub release create \
                            --file $RELEASE_MESSAGE_FILE \
                            --commitish $TARGET_BRANCH \
                            $BUGFIX_VERSION
                    fi

            - if: failure()
              env:
                  SLACK_API_TOKEN: ${{ secrets.SLACK_API_TOKEN }}
              run: |
                  echo "Do a slack message."
