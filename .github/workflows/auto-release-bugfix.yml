name: Automated Bugfix Release
on:
    schedule:
        # Noon PST on Friday of each week
        #- cron: '0 20 * * 5'
        - cron: '*/5 * * * *'

jobs:
    create-bugfix-release:
        name: Create a bugfix release
        runs-on: ubuntu-latest
        env:
            SOURCE_BRANCH: feature/automated-releases
        steps:
            - uses: actions/checkout@v2
              with:
                  ref: ${{ env.SOURCE_BRANCH }}
                  fetch-depth: 0  # fetch complete history

            - run: git fetch origin +refs/tags/*:refs/tags/*

            - uses: actions/setup-python@v1
              with:
                  python-version: 3.7

            - run: pip install --upgrade requests toml
            - run: pip install $(python -c "import toml;print(' '.join(toml.load('pyproject.toml')['build-system']['requires']))")

            # Pandoc needed for pandoc-based text conversion.
            # gettext-base needed for the envsubst program.
            - run: sudo apt-get update --fix-missing && sudo apt-get install pandoc gettext-base

            - name: Testing for and preparing the release
              env:
                  SOURCE_BRANCH: ${{ env.SOURCE_BRANCH }}
                  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
              run: |
                  # Redirecting stderr to /dev/null to keep actions logs
                  # reflecting the expected state of the program.
                  if hub ci-status $SOURCE_BRANCH 2> /dev/null
                  then
                      echo "There are test failures on $SOURCE_BRANCH; aborting release."
                      exit 1
                  fi

                  # Don't do a bugfix release if target branch's HEAD already has a tag
                  # git-describe exits 0 if a tag is found, 128 if not.
                  # Redirecting stderr to /dev/null to keep the expected
                  # 'fatal' error message out of the actions logs.
                  if git describe --exact-match --tags $SOURCE_BRANCH 2> /dev/null
                  then
                      echo "The latest commit on $SOURCE_BRANCH already has a tag"
                  else
                      LATEST_TAG=$(git describe --tags | awk -F '-' '{print $1}')
                      echo "Latest tag on $SOURCE_BRANCH is $LATEST_TAG"
                      if [[ $LATEST_TAG =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]
                      then
                          echo "$LATEST_TAG identified as a full release."
                          echo "Proceeding with automated bugfix release."
                      else
                          echo "$LATEST_TAG does not conform to bugfix versioning."
                          echo "This script does not know how to handle non-bugfix releases."
                          echo "Aborting."
                          exit 1
                      fi

                      export BUGFIX_VERSION=$(python setup.py --version | awk -F '.' '{print $1"."$2"."$3+1}')

                      # Update the UG hash in the Makefile
                      # This could be done with curl and sed, but it'll be easier
                      # to read this way.
                      python ci/release/increment-userguide-revision.py

                      # Update HISTORY with the tag and today's date.
                      python ci/release/update-history.py $BUGFIX_VERSION $(date "+%Y-%m-%d")

                      # Need to set up these committer details before
                      # anything can be committed.
                      git config user.email "jdouglass@stanford.edu"
                      git config user.name "James Douglass"

                      # Commit changes and make an annotated tag.
                      git add Makefile HISTORY.rst
                      git status | cat  # for debugging.
                      TARGET_BRANCH=autorelease/$BUGFIX_VERSION
                      git checkout -b $TARGET_BRANCH
                      git commit -m "Auto-committing updates for the $BUGFIX_VERSION release"
                      git tag -a $BUGFIX_VERSION -m "$BUGFIX_VERSION release."

                      # Only push revisions needed to push the tag created.
                      # NOTE: If changes were pushed to $TARGET_BRANCH before
                      #       we try to push this release, the push will fail and
                      #       we'll avoid the race condition.
                      # NOTE: This push will NOT trigger other workflows because it's
                      #       authenticated with $GITHUB_TOKEN.  By design, events
                      #       authenticated with this token will not cause
                      #       recursive workflow calls.
                      GIT_REPO=https://$GITHUB_ACTOR:$GITHUB_TOKEN@github.com/$GITHUB_REPOSITORY.git
                      git push --tags $GIT_REPO $TARGET_BRANCH

                      RELEASE_MESSAGE_FILE=release_message.md
                      VERSION=$BUGFIX_VERSION ./ci/release/build-release-text-from-history.sh > $RELEASE_MESSAGE_FILE
                      cat $RELEASE_MESSAGE_FILE  # for debugging, just in case.

                      # Create a release object based on the text from HISTORY.
                      # This requires that the tag already exists in the
                      # repository on github.
                      # NOTE: creating a GitHub release creates the tag.
                      #       The InVEST binaries are created in response to
                      #       this release object being created.  See the
                      #       upload-binaries-to-release build job in
                      #       .github/workflows/binary-applications.yml.
                      # NOTE: The User Access Token used must have repository
                      #       push permissions.  If the target repo is public, then
                      #       only the ``public_repo`` permission is needed.
                      #       See the list/descriptions of available scopes at:
                      #       https://developer.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/#available-scopes
                      GITHUB_TOKEN=${{ secrets.USER_ACCESS_TOKEN }} hub release create \
                          --draft \
                          --file $RELEASE_MESSAGE_FILE \
                          --commitish $TARGET_BRANCH \
                          $BUGFIX_VERSION

                      # Python wheels are created in response to the release.
                      # Create an issue for uploading the wheels to PyPI here
                      # so that we remember to take care of this.
                      hub issue create \
                          --message "Release natcap.invest $BUGFIX_VERSION on PyPI" \
                          --message "When built, remember to upload wheels for $BUGFIX_VERSION to PyPI." \
                          --labels task

                      # Create a new pull request from the new autorelease
                      # branch back into the source branch.
                      PRMSG=prmsg.txt
                      envsubst ci/release/bugfix-autorelease-branch-pr-body.md > $PRMSG
                      hub pull-request \
                          --base $GITHUB_REPOSITORY:$SOURCE_BRANCH \
                          --head $GITHUB_REPOSITORY:$TARGET_BRANCH \
                          --reviewer "natcap/software-team" \
                          --assign "natcap/software-team" \
                          --file $PRMSG
                  fi

            # Notify us on slack only on failure.
            # When a release is created, we'll be notified on slack about that
            # anyways.  The build does not fail if there are no commits to
            # release from master.
            - name: Notify build status on slack
              uses: homoluctus/slatify@master
              if: failure()
              with:
                  type: ${{ job.status }}
                  job_name: '*InVEST Bugfix Auto-Release*'
                  mention: 'here'
                  mention_if: 'always'
                  url: ${{ secrets.SLACK_WEBHOOK }}
                  commit: true
                  token: ${{ secrets.GITHUB_TOKEN }}
